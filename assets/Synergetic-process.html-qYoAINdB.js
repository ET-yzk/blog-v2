import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as e,o,c,a as n,b as s,d as i,f as a}from"./app-HHaGRXeI.js";const l={},u=a(`<h1 id="协程" tabindex="-1"><a class="header-anchor" href="#协程" aria-hidden="true">#</a> 协程</h1><blockquote><p>**协程，英文Coroutines，是一种比线程更加轻量级的存在。**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p></blockquote><h2 id="什么是进程和线程" tabindex="-1"><a class="header-anchor" href="#什么是进程和线程" aria-hidden="true">#</a> 什么是进程和线程</h2><p><strong>进程是什么呢？</strong></p><p>直白地讲，进程就是应用程序的启动实例。比如我们运行一个游戏，打开一个软件，就是开启了一个进程。</p><p>进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</p><p><strong>线程又是什么呢？</strong></p><p>线程从属于进程，是程序的实际执行者。一个进程至少包含一个主线程，也可以有更多的子线程。</p><p>线程拥有自己的栈空间。</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110241608412.jpeg" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>有人给出了很好的归纳：</p><p><strong>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元。</strong></p><p>无论进程还是线程，都是由<strong>操作系统</strong>所管理的。</p><p>Java中线程具有五种状态：</p><p><strong>初始化</strong>、<strong>可运行</strong>、<strong>运行中</strong>、<strong>阻塞</strong>、<strong>销毁</strong></p><p>这五种状态的转化关系如下：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110241612974.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>但是，线程不同状态之间的转化是谁来实现的呢？是JVM吗？</p><p>并不是。JVM需要通过操作系统内核中的TCB（Thread Control Block）模块来改变线程的状态，这一过程需要耗费一定的CPU资源。</p><h2 id="进程和线程的痛点" tabindex="-1"><a class="header-anchor" href="#进程和线程的痛点" aria-hidden="true">#</a> 进程和线程的痛点</h2><p>线程之间是如何进行协作的呢？</p><p>最经典的例子就是<strong>生产者/消费者模式</strong>：</p><p>若干个生产者线程向队列中写入数据，若干个消费者线程从队列中消费数据。</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110241613133.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>如何用java语言实现生产者/消费者模式呢？</p><p>让我们来看一看代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConsumerTest</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">final</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> sharedQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Thread</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Thread</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
		producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_QUEUE_SIZE</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span> sharedQueue<span class="token punctuation">;</span>
    
	<span class="token keyword">public</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>sharedQueue <span class="token operator">=</span> sharedQueue<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token constant">MAX_QUEUE_SIZE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;队列满了，等待消费&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

					<span class="token keyword">try</span> <span class="token punctuation">{</span>
						sharedQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
						e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
                
				sharedQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;进行生产 : &quot;</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
				sharedQueue<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>

	<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span> sharedQueue<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token class-name">Queue</span> sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>sharedQueue <span class="token operator">=</span> sharedQueue<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>sharedQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token keyword">try</span> <span class="token punctuation">{</span>
						<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;队列空了，等待生产&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						sharedQueue<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
						e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">int</span> number <span class="token operator">=</span> sharedQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;进行消费 : &quot;</span> <span class="token operator">+</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
				sharedQueue<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码做了下面几件事：</p><ol><li><p>定义了一个生产者类，一个消费者类。</p></li><li><p>生产者类循环100次，向同步队列当中插入数据。</p></li><li><p>消费者循环监听同步队列，当队列有数据时拉取数据。</p></li><li><p>如果队列满了（达到5个元素），生产者阻塞。</p></li><li><p>如果队列空了，消费者阻塞。</p></li></ol><p>上面的代码正确地实现了生产者/消费者模式，但是却并不是一个高性能的实现。为什么性能不高呢？原因如下：</p><ol><li><p>涉及到同步锁。</p></li><li><p>涉及到线程阻塞状态和可运行状态之间的切换。</p></li><li><p>涉及到线程上下文的切换。</p></li></ol><p>以上涉及到的任何一点，都是非常耗费性能的操作。</p><h2 id="协程的优势" tabindex="-1"><a class="header-anchor" href="#协程的优势" aria-hidden="true">#</a> 协程的优势</h2><p><strong>什么是协程</strong></p><p><strong>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</strong></p><p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p><p>协程与进程、线程相比不是一个维度的概念，但是有时候，我们仍然需要将它们做一番比较，具体如下：</p><ol><li><p>协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程跟他们就不是一个维度。</p></li><li><p>一个进程可以包含多个线程，一个线程可以包含多个协程。</p></li><li><p>一个线程内的多个协程虽然可以切换，但是这多个协程是串行执行的，只能在这一个线程内运行，没法利用CPU多核能力。</p></li></ol><p>4 协程与进程、线程一样，它们的切换都存在上下文切换问题。</p><p>表面上，进程、线程、协程都存在上下文切换的问题，但是三者上下文切换又有明显不同，见下表：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110241622875.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><h2 id="协程的使用场景" tabindex="-1"><a class="header-anchor" href="#协程的使用场景" aria-hidden="true">#</a> 协程的使用场景</h2><p><strong>一个线程内的多个协程是串行执行的</strong>，不能利用多核，所以，显然，协程不适合计算密集型的场景。<strong>协程适合I/O 阻塞型。</strong></p><p>I/O本身就是阻塞型的（相较于CPU的时间世界而言）。就目前而言，无论I/O的速度多快，也比不上CPU的速度，所以一个I/O相关的程序，当其在进行I/O操作时候，CPU实际上是空闲的。</p><p>我们假设这样的场景，如下图：1个线程有5个I/O的事情（子程序）要处理。如果我们绝对的串行化，那么当其中一个I/O阻塞时，其他4个I/O并不能得到执行，因为程序是绝对串行的，5个I/O必须一个一个排队等待处理，当一个I/O阻塞时，其它4个也得等着。</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110241624748.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>而协程能比较好地处理这个问题，当一个协程（特殊子进程）阻塞时，它可以切换到其他没有阻塞的协程上去继续执行，这样就能得到比较高的效率，如下图所示：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110241624875.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>上面举的例子是5个I/O处理，如果每秒500个，5万个或500万个呢？已经达到了“I/O密集型”的程度，而**“I/O密集型”确实是协程无法应付的，因为它没有利用多核的能力。这个时候的解决方案就是“多进程+协程”了。**</p><p>所以说，I/O阻塞时，利用协程来处理确实有优点（切换效率比较高），但是我们也需要看到其不能利用多核的这个缺点，必要的时候，还需要使用综合方案：多进程+协程。</p>`,50),r={id:"kotlin-jetpack-实战-图解协程原理",tabindex:"-1"},k=n("a",{class:"header-anchor",href:"#kotlin-jetpack-实战-图解协程原理","aria-hidden":"true"},"#",-1),d={href:"https://mp.weixin.qq.com/s/7nAs1T4hh_lGpEEEYjTVDg",target:"_blank",rel:"noopener noreferrer"},v=a('<h2 id="个人理解" tabindex="-1"><a class="header-anchor" href="#个人理解" aria-hidden="true">#</a> 个人理解</h2><p>Kotlin 的协程，核心在于其内部新定义实现的<em>单例</em> 子类 <code>ContinuationImpl</code>，本质为 CPS + 状态机，核心使得本质运行。</p><p><code>ContinuationImpl</code> 实现了对状态机的状态的标识，<code>invokeSuspend()</code> 回调函数对 <code>CPS</code>(<code>this</code>) 的回调。</p><p>大致步骤如下：</p><ol><li><p>对各挂起函数 ( <code>suspend</code> 修饰 ) 进行 <code>CPS转换</code> ( <code>Continuation-Passing-Style Transformation</code> )</p></li><li><p>为 continuation 参数赋值，如果该值为 <code>ContinuationImpl</code> 类型，则延用该类，否则调用定义的子类 <code>ContinuationImpl</code> 进行包装 ( 一般只要在初次赋值包装 )。</p></li><li><p>进入 <code>whe(continuation.label){ x -&gt; {}}</code> 状态机判断，更新状态标记 <code>label</code> 并调用<strong>IO线程</strong>执行挂起函数体，其中挂起函数 <code>withContext(Dispatchers.IO){ x }</code> 的调用将直接返回 <strong>挂起状态码</strong>，状态机状态机检测到该值后，将响应挂起函数的回调。</p></li><li><p>若加入 <code>suspend</code> 修饰的函数中不包含 <code>withContext(Dispatchers.IO){ x }</code> 实现挂起进程，则该函数为<strong>伪函数</strong>，状态机将判断其未进入挂起状态，通过跳转到 <code>when</code> 前的 <code>label</code> 赋值进入下一状态，也即该函数还是在<strong>主线程</strong>完成的。</p></li><li><p>循环往复，直至到达最终状态为止。</p></li></ol>',5);function m(g,b){const t=e("ExternalLinkIcon");return o(),c("div",null,[u,n("h2",r,[k,s(),n("a",d,[s("Kotlin Jetpack 实战：图解协程原理"),i(t)])]),v])}const w=p(l,[["render",m],["__file","Synergetic-process.html.vue"]]);export{w as default};
