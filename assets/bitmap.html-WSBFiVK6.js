import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as p,c as i,a,b as n,d as o,f as r}from"./app-HHaGRXeI.js";const c={},l={id:"bitmap简介",tabindex:"-1"},d=a("a",{class:"header-anchor",href:"#bitmap简介","aria-hidden":"true"},"#",-1),u={href:"https://www.cnblogs.com/cjsblog/p/11613708.html",target:"_blank",rel:"noopener noreferrer"},h=r(`<h2 id="_1-bitmap" tabindex="-1"><a class="header-anchor" href="#_1-bitmap" aria-hidden="true">#</a> 1. BitMap</h2><p>Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。（PS：划重点 <strong>节省存储空间</strong>）</p><p>假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存</p><p>在Java中，int占4字节，1字节=8位（1 byte = 8 bit）</p><p>如果每个数字用int存储，那就是20亿个int，因而占用的空间约为 (2000000000*4/1024/1024/1024)≈<strong>7.45</strong>G</p><p>如果按位存储就不一样了，20亿个数就是20亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈<strong>0.2****33</strong>G</p><p>高下立判，无需多言</p><p>那么，问题来了，如何表示一个数呢？</p><h3 id="表示" tabindex="-1"><a class="header-anchor" href="#表示" aria-hidden="true">#</a> 表示</h3><p>刚才说了，每一位表示一个数，0表示不存在，1表示存在，这正符合二进制</p><p>这样我们可以很容易表示{1,2,4,6}这几个数：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/874963-20190930154945790-1681218156.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>计算机内存分配的最小单位是字节，也就是8位，那如果要表示{12,13,15}怎么办呢？</p><p>当然是在另一个8位上表示了：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/874963-20190930161508728-1545815203.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>这样的话，好像变成一个二维数组了</p><p>1个int占32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32] 即可存储，其中N表示要存储的这些数中的最大值，于是乎：</p><p>tmp[0]：可以表示0~31</p><p>tmp[1]：可以表示32~63</p><p>tmp[2]：可以表示64~95</p><p>。。。</p><p>如此一来，给定任意整数M，那么M/32就得到下标，M%32就知道它在此下标的哪个位置</p><h3 id="添加" tabindex="-1"><a class="header-anchor" href="#添加" aria-hidden="true">#</a> 添加</h3><p>这里有个问题，我们怎么把一个数放进去呢？例如，想把5这个数字放进去，怎么做呢？</p><p>首先，5/32=0，5%32=5，也是说它应该在tmp[0]的第5个位置，那我们把1向左移动5位，然后按位或</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/874963-20190930170044824-1061422457.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>换成二进制就是</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/874963-20190930174515759-289489948.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>这就相当于 86 | 32 = 118</p><p>86 | (1&lt;&lt;5) = 118</p><p>b[0] = b[0] | (1&lt;&lt;5)</p><p>也就是说，要想插入一个数，将1左移带代表该数字的那一位，然后与原数进行按位或操作</p><p>化简一下，就是 86 + (5/8) | (1&lt;&lt;(5%8))</p><p>因此，公式可以概括为：p + (i/8)|(1&lt;&lt;(i%8)) 其中，p表示现在的值，i表示待插入的数</p><h3 id="清除" tabindex="-1"><a class="header-anchor" href="#清除" aria-hidden="true">#</a> 清除</h3><p>以上是添加，那如果要清除该怎么做呢？</p><p>还是上面的例子，假设我们要6移除，该怎么做呢？</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/874963-20191013123453790-20308625.png" alt="img" tabindex="0"><figcaption>img</figcaption></figure><p>从图上看，只需将该数所在的位置为0即可</p><p>1左移6位，就到达6这个数字所代表的位，然后按位取反，最后与原数按位与，这样就把该位置为0了</p><p>b[0] = b[0] &amp; (~(1&lt;&lt;6))</p><p>b[0] = b[0] &amp; (~(1&lt;&lt;(i%8)))</p><h3 id="查找" tabindex="-1"><a class="header-anchor" href="#查找" aria-hidden="true">#</a> 查找</h3><p>前面我们也说了，每一位代表一个数字，1表示有（或者说存在），0表示无（或者说不存在）。通过把该为置为1或者0来达到添加和清除的小伙，那么判断一个数存不存在就是判断该数所在的位是0还是1</p><p>假设，我们想知道3在不在，那么只需判断 b[0] &amp; (1&lt;&lt;3) 如果这个值是0，则不存在，如果是1，就表示存在</p><h2 id="_2-bitmap有什么用" tabindex="-1"><a class="header-anchor" href="#_2-bitmap有什么用" aria-hidden="true">#</a> 2. Bitmap有什么用</h2><p>大量数据的快速排序、查找、去重</p><h3 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h3><p>假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）,我们就可以采用Bit-map的方法来达到排序的目的。</p><p>要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0，然后将对应位置为1。</p><p>最后，遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的，时间复杂度O(n)。</p><p>优点：</p><ul><li>运算效率高，不需要进行比较和移位；</li><li>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M</li></ul><p>缺点：</p><ul><li>所有的数据不能重复。即不可对重复的数据进行排序和查找。</li><li>只有当数据比较密集时才有优势</li></ul><h3 id="快速去重" tabindex="-1"><a class="header-anchor" href="#快速去重" aria-hidden="true">#</a> 快速去重</h3><p>20亿个整数中找出不重复的整数的个数，内存不足以容纳这20亿个整数。</p><p>首先，根据“内存空间不足以容纳这05亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这20亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间2G左右。</p><p>接下来的任务就是把这20亿个数字放进去（存储），如果对应的状态位为00，则将其变为01，表示存在一次；如果对应的状态位为01，则将其变为11，表示已经有一个了，即出现多次；如果为11，则对应的状态位保持不变，仍表示出现多次。</p><p>最后，统计状态位为01的个数，就得到了不重复的数字个数，时间复杂度为O(n)。</p><h3 id="快速查找" tabindex="-1"><a class="header-anchor" href="#快速查找" aria-hidden="true">#</a> 快速查找</h3><p>这就是我们前面所说的了，int数组中的一个元素是4字节占32位，那么除以32就知道元素的下标，对32求余数（%32）就知道它在哪一位，如果该位是1，则表示存在。</p><h2 id="小结-回顾" tabindex="-1"><a class="header-anchor" href="#小结-回顾" aria-hidden="true">#</a> 小结&amp;回顾</h2><p>Bitmap主要用于快速检索关键字状态，通常要求关键字是一个连续的序列（或者关键字是一个连续序列中的大部分）， 最基本的情况，使用1bit表示一个关键字的状态（可标示两种状态），但根据需要也可以使用2bit（表示4种状态），3bit（表示8种状态）。</p><p>Bitmap的主要应用场合：表示连续（或接近连续，即大部分会出现）的关键字序列的状态（状态数/关键字个数 越小越好）。</p><p>32位机器上，对于一个整型数，比如int a=1 在内存中占32bit位，这是为了方便计算机的运算。但是对于某些应用场景而言，这属于一种巨大的浪费，因为我们可以用对应的32bit位对应存储十进制的0-31个数，而这就是Bit-map的基本思想。Bit-map算法利用这种思想处理大量数据的排序、查询以及去重。</p><h3 id="补充1" tabindex="-1"><a class="header-anchor" href="#补充1" aria-hidden="true">#</a> 补充1</h3><p>在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方，右移一位相当于除2，右移n位相当于除以2的n次方。</p><p>&lt;&lt; 左移，相当于乘以2的n次方，例如：1&lt;&lt;6 相当于1×64=64，3&lt;&lt;4 相当于3×16=48</p><p>&gt;&gt; 右移，相当于除以2的n次方，例如：64&gt;&gt;3 相当于64÷8=8</p><p>^ 异或，相当于求余数，例如：48^32 相当于 48%32=16</p><h3 id="补充2" tabindex="-1"><a class="header-anchor" href="#补充2" aria-hidden="true">#</a> 补充2</h3><p>不使用第三方变量，交换两个变量的值</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token comment">// 方式一</span>
a <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>
a <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span>

<span class="token comment">// 方式二</span>
a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
a <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
</code></pre></div><h2 id="_3-bitset" tabindex="-1"><a class="header-anchor" href="#_3-bitset" aria-hidden="true">#</a> 3. BitSet</h2><p>BitSet实现了一个位向量，它可以根据需要增长。每一位都有一个布尔值。一个BitSet的位可以被非负整数索引（PS：意思就是每一位都可以表示一个非负整数）。可以查找、设置、清除某一位。通过逻辑运算符可以修改另一个BitSet的内容。默认情况下，所有的位都有一个默认值false。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BitSet</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>
    <span class="token comment">/*
     * BitSet are packed into arrays of &quot;words&quot;. Currently a word is 
     * a long, which consists of 64 bits, requiring 6 address bits.
     * The choice of word size is determined purely by performande concerns.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">ADDRESS_BITS_PER_WORD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">BITS_PER_WORD</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">ADDRESS_BITS_PER_WORD</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token constant">BIT_INDEX_MASK</span> <span class="token operator">=</span> <span class="token constant">BITS_PER_WORD</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    
    <span class="token comment">/* Used to shift left or right for a partial word mask */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token constant">WORD_MASK</span> <span class="token operator">=</span> <span class="token number">0</span>xffffffffffffffffl<span class="token punctuation">;</span>
    
    
<span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-redis-bitmap相关应用" tabindex="-1"><a class="header-anchor" href="#_4-redis-bitmap相关应用" aria-hidden="true">#</a> <strong>4. REDIS bitmap相关应用</strong></h2><p>自己造轮子太累，redis提供了类似的命令，最大可以存放2的32次方，即21亿多的数字，主要有以下几个：SETBIT， GETBIT， BITCOUNT， BITOP， BITPOS，BITFIELD，</p><p>主要用来做活跃用户在线状态、活跃用户统计、用户签到等场景，特别适合大量用户，几千万上亿级别，当然你用传统数据库也能做，但是redis做起来更简单，更节省空间！</p><p>下面举一个用户签到的功能设计案例：</p><p>很多App都有一个签到功能，比如说连续签到7天或者30天给一些奖励，需求十分简单！</p><p>作为后端，我们需要提供一个签到接口，然后记录用户签到的信息，比如用户uid，签到时间！</p><p>如果使用传统关系型数据库，我们可能需要建一张签到表，大概有id、uid、createdTime等几个字段，当用户签到的时候新增一条记录就行！这种做法肯定是没问题的，但是如果网站每天有千万用户签到，那么这张表每天都会有千万条记录产生，数据的存储是问题！分库分表必不可少！</p><p>假如使用redis的bit操作，我们可以使用setbit，<code>SETBIT key offset value</code> 对指定的key的value的指定偏移(offset)的位置1或0, 其中key我们可以设置为当天的年月日，offset是用户uid（这里暂时只考虑uid是纯数字的情况）,value的话1表示已签到。比如说用户uid位12500的用户在20190501签到了，我们可以执行<code>SETBIT 20190501 12500 1</code>,其它用户依此论推！</p><p>如果我们需要查询用户某天是否签到，只需要使用<code>GETBIT 20190501 12500</code>，返回1表示已签到，0未签到。</p><p>如果需要查询某天有多少人签到，可以使用<code>BITCOUNT 20190501</code>。</p><p>如果要统计连续7天签到的总人数的话可以使用bitop命令，比如<code>bitop AND 7_dasy_sign 20190501 20190502 20190503 ... 20190507</code>。</p><p>理论上讲，setbit的大小在0到2的32次方（最大使用512M内存）之间，即0~4294967296之间，也就说最多可以存储42亿用户的签到情况。和数据库相比，这种方式查询的效率非常高，并不会因为数据大而变慢，而且比较节省内存，操作上也不是太复杂。</p><h2 id="后记" tabindex="-1"><a class="header-anchor" href="#后记" aria-hidden="true">#</a> 后记</h2><blockquote><p>问: &quot;有10亿个不重复的无序的数字，如果快速排序？&quot;</p></blockquote><p>面试中经常会问到类似问题，看上去很简单，就是一个排序而已，但是你好好想想大部分排序算法都需要把数据放到内存里面操作，这10亿个数字得占用多少内存？好吧，你可以使用外部排序算法，在磁盘上完成排序！当然这些传统算法肯定是可以解决的，不过这里有一个更好的方案，采用bitmap排序。</p><p>提到这个算法的好处，最大的好处就是节省内存，节省了好几十倍，适合处理大量数据，除了快速排序，还可以做快速去重，快速查询是否存在，还有一个比较好听的应用 Bloom Filter(布隆过滤器):</p><blockquote><p>Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素x，第i个哈希函数映射的位置hi(x)就会被置为1（1≤i≤k）。注：如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。 Bloom Filter 在判断y是否属于这个集合时，对y应用k次哈希函数，若所有hi(y)的位置都是1（1≤i≤k），就认为y是集合中的元素，否则就认为y不是集合中的元素。</p></blockquote>`,94);function k(b,m){const s=t("ExternalLinkIcon");return p(),i("div",null,[a("h1",l,[d,n(),a("a",u,[n("Bitmap简介"),o(s)])]),h])}const v=e(c,[["render",k],["__file","bitmap.html.vue"]]);export{v as default};
