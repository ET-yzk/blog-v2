import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o,c as e,a as n,b as a,d as c,f as i}from"./app-HHaGRXeI.js";const u={},l=n("h1",{id:"函数回调",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#函数回调","aria-hidden":"true"},"#"),a(" 函数回调")],-1),k={href:"https://www.zhihu.com/people/mac-82-59",target:"_blank",rel:"noopener noreferrer"},r=i(`<p>不知你是不是也有这样的疑惑，我们为什么需要回调函数这个概念呢？直接调用函数不就可以了？回调函数到底有什么作用？程序员到底该如何理解回调函数？</p><h2 id="一切要从这样的需求说起" tabindex="-1"><a class="header-anchor" href="#一切要从这样的需求说起" aria-hidden="true">#</a> 一切要从这样的需求说起</h2><p>假设你们公司要开发下一代国民App“明日油条”，一款主打解决国民早餐问题的App，为了加快开发进度，这款应用由A小组和B小组协同开发。</p><p>其中有一个核心模块由A小组开发然后供B小组调用，这个核心模块被封装成了一个函数，这个函数就叫make_youtiao()。</p><p>如果make_youtiao()这个函数执行的很快并可以立即返回，那么B小组的同学只需要：</p><ol><li>调用make_youtiao()</li><li>等待该函数执行完成</li><li>该函数执行完后继续后续流程</li></ol><p>从程序执行的角度看这个过程是这样的：</p><ol><li>保存当前被执行函数的上下文</li><li>开始执行make_youtiao()这个函数</li><li>make_youtiao()执行完后，控制转回到调用函数中</li></ol><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251857028.jpg" alt="1" tabindex="0"><figcaption>1</figcaption></figure><p>如果世界上所有的函数都像make_youtiao()这么简单，那么程序员大概率就要失业了，还好程序的世界是复杂的，这样程序员才有了存在的价值。</p><h2 id="现实情况并不容易" tabindex="-1"><a class="header-anchor" href="#现实情况并不容易" aria-hidden="true">#</a> 现实情况并不容易</h2><p>现实中make_youtiao()这个函数需要处理的数据非常庞大，假设有10000个，<strong>那么make_youtiao(10000)不会立刻返回</strong>，而是可能需要10分钟才执行完成并返回。</p><p>这时你该怎么办呢？想一想这个问题。</p><p>可能有的同学就像把头埋在沙子里的鸵鸟一样：和刚才一样直接调用不可以吗，这样多简单。</p><p>是的，这样做没有问题，但就像爱因斯坦说的那样“一切都应该尽可能简单，但是不能过于简单”。</p><p>想一想直接调用会有什么问题？</p><p>显然直接调用的话，那么调用线程会被阻塞暂停，在等待10分钟后才能继续运行。在这10分钟内该线程不会被操作系统分配CPU，也就是说该线程得不到任何推进。</p><p>这并不是一种高效的做法。</p><p>没有一个程序员想死盯着屏幕10分钟后才能得到结果。</p><p>那么有没有一种更加高效的做法呢？</p><h2 id="同步与异步" tabindex="-1"><a class="header-anchor" href="#同步与异步" aria-hidden="true">#</a> 同步与异步</h2><p>我们已经知道了这种<strong>一直等待直到另一个任务完成的</strong>模式叫做同步。</p><p>如果你是老板的话你会什么都不干一直盯着员工写代码吗？因此一种更好的做法是程序员在代码的时候老板该干啥干啥，程序员写完后自然会通知老板，这样老板和程序员都不需要相互等待，这种模式被称为异步。</p><p>回到我们的主题，这里一种更好的方式是<strong>调用make_youtiao()这个函数后不再等待这个函数执行完成</strong>，而是直接返回继续后续流程，这样A小组的程序就可以和make_youtiao()这个函数同时进行了，就像这样：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251911744.jpg" alt="2" tabindex="0"><figcaption>2</figcaption></figure><p>在这种情况下，回调(callback)就必须出场了。</p><h2 id="为什么我们需要回调callback" tabindex="-1"><a class="header-anchor" href="#为什么我们需要回调callback" aria-hidden="true">#</a> 为什么我们需要回调callback</h2><p>有的同学可能还没有明白为什么在这种情况下需要回调，别着急，我们慢慢讲。</p><p>假设我们“明日油条”App代码第一版是这样写的：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">make_youtiao</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到这是最简单的写法，意思很简单，制作好油条后卖出去。</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251911066.jpg" alt="3" tabindex="0"><figcaption>3</figcaption></figure><p>我们已经知道了由于make_youtiao(10000)这个函数10分钟才能返回，你不想一直死盯着屏幕10分钟等待结果，那么一种更好的方法是让make_youtiao()这个函数知道制作完油条后该干什么，即，更好的调用make_youtiao的方式是这样的：“制作10000个油条，<strong>炸好后卖出去</strong>”，因此调用make_youtiao就变出这样了：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">make_youtiao</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span> sell<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>看到了吧，现在make_youtiao这个函数多了一个参数，除了指定制作油条的数量外<strong>还可以指定制作好后该干什么</strong>，第二个被make_youtiao这个函数调用的函数就叫回调，callback。</p><p>现在你应该看出来了吧，虽然sell函数是你定义的，但是这个函数却是被其它模块调用执行的，就像这样：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251912197.jpg" alt="4" tabindex="0"><figcaption>4</figcaption></figure><p>make_youtiao这个函数是怎么实现的呢，很简单：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">make_youtiao</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> func call_back<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 制作油条</span>
    <span class="token function">call_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行回调 </span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样你就不用死盯着屏幕了，因为你把make_youtiao这个函数执行完后该做的任务交代给make_youtiao这个函数了，该函数制作完油条后知道该干些什么，这样就解放了你的程序。</p><p>有的同学可能还是有疑问，为什么编写make_youtiao这个小组不直接定义sell函数然后调用呢？</p><p>不要忘了明日油条这个App是由A小组和B小组同时开发的，A小组在编写make_youtiao时怎么知道B小组要怎么用这个模块，假设A小组真的自己定义sell函数就会这样写：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">make_youtiao</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">real_make_youtiao</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行回调 </span>
<span class="token punctuation">}</span>
</code></pre></div><p>同时A小组设计的模块非常好用，这时C小组也想用这个模块，然而C小组的需求是制作完油条后放到仓库而不是不是直接卖掉，要满足这一需求那么A小组该怎么写呢？</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">make_youtiao</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">real_make_youtiao</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>Team_B<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行回调</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Team_D<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放到仓库</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>故事还没完，假设这时D小组又想使用呢，难道还要接着添加if else吗？这个问题该怎么解决呢？关于这个问题的答案，你懂的。</p><h2 id="新的编程思维模式" tabindex="-1"><a class="header-anchor" href="#新的编程思维模式" aria-hidden="true">#</a> 新的编程思维模式</h2><p>让我们再来仔细的看一下这个过程。</p><p>程序员最熟悉的思维模式是这样的：</p><ol><li>调用某个函数，获取结果</li><li>处理获取到的结果</li></ol><div class="language-c" data-ext="c"><pre class="language-c"><code>res <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">handle</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这就是函数的同步调用，只有request()函数返回拿到结果后，才能调用handle函数进行处理，request函数返回前我们必须<strong>等待</strong>，这就是同步调用，其控制流是这样的：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251913923.jpg" alt="5" tabindex="0"><figcaption>5</figcaption></figure><p>但是如果我们想更加高效的话，那么就需要异步调用了，我们不去直接调用handle函数，而是作为参数传递给request：</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">request</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们根本就不关心request什么时候真正的获取的结果，这是request该关心的事情，我们只需要把获取到结果后该怎么处理告诉request就可以了，因此request函数可以立刻返回，真的获取结果的处理可能是在另一个线程、进程、甚至另一台机器上完成。</p><p>这就是异步调用，其控制流是这样的：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251913273.jpg" alt="6" tabindex="0"><figcaption>6</figcaption></figure><p>从编程思维上看，异步调用和同步有很大的差别，如果我们把处理流程当做一个任务来的话，那么同步下整个任务都是我们来实现的，但是异步情况下任务的处理流程被分为了两部分：</p><ol><li>第一部分是我们来处理的，也就是调用request之前的部分</li><li>第二部分不是我们处理的，而是在其它线程、进程、甚至另一个机器上处理的。</li></ol><p>我们可以看到由于任务被分成了两部分，第二部分的调用不在我们的掌控范围内，同时只有调用方才知道该做什么，因此在这种情况下回调函数就是一种必要的机制了。</p><p>也就是说回调函数的本质就是“只有我们才知道做些什么，但是我们并不清楚什么时候去做这些，只有其它模块才知道，因此我们必须把我们知道的封装成回调函数告诉其它模块”。</p><p>现在你应该能看出异步回调这种编程思维模式和同步的差异了吧。</p><p>接下来我们给回调一个较为学术的定义</p><h2 id="正式定义" tabindex="-1"><a class="header-anchor" href="#正式定义" aria-hidden="true">#</a> 正式定义</h2><blockquote><p>在计算机科学中，回调函数是指一段以参数的形式传递给其它代码的可执行代码。</p></blockquote><p>这就是回调函数的定义了。</p><p>回调函数就是一个函数，和其它函数没有任何区别。</p><p>注意，回调函数是一种软件设计上的概念，和某个编程语言没有关系，几乎所有的编程语言都能实现回调函数。</p><p>对于一般的函数来说，我们自己编写的函数会在自己的程序内部调用，也就是说函数的编写方是我们自己，调用方也是我们自己。</p><p>但回调函数不是这样的，虽然函数编写方是我们自己，但是函数调用方不是我们，而是我们引用的其它模块，也就是第三方库，我们调用第三方库中的函数，并把回调函数传递给第三方库，第三方库中的函数调用我们编写的回调函数，如图所示：</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251913384.jpg" alt="7" tabindex="0"><figcaption>7</figcaption></figure><p>而之所以需要给第三方库指定回调函数，是因为第三方库的编写者并不清楚在某些特定节点，比如我们举的例子油条制作完成、接收到网络数据、文件读取完成等之后该做什么，这些只有库的使用方才知道，因此第三方库的编写者无法针对具体的实现来写代码，而只能对外提供一个回调函数，库的使用方来实现该函数，第三方库在特定的节点调用该回调函数就可以了。</p><p>另一点值得注意的是，从图中我们可以看出回调函数和我们的主程序位于<strong>同一层</strong>中，我们只负责编写该回调函数，但并不是我们来调用的。</p><p>最后值得注意的一点就是回调函数被调用的时间节点，回调函数只在某些特定的节点被调用，就像上面说的油条制作完成、接收到网络数据、文件读取完成等，这些都是事件，也就是event，本质上我们编写的回调函数就是用来处理event的，因此从这个角度看回调函数不过就是event handler，因此回调函数天然适用于事件驱动编程event-driven，我们将会在后续文章中再次回到这一主题。</p><h2 id="回调的类型" tabindex="-1"><a class="header-anchor" href="#回调的类型" aria-hidden="true">#</a> 回调的类型</h2><p>我们已经知道有两种类型的回调，这两种类型的回调区别在于回调函数被调用的时机。</p><p><strong>同步回调</strong></p><p>这种回调就是通常所说的同步回调synchronous callbacks、也有的将其称为阻塞式回调blocking callbacks，或者什么修饰都没有，就是回调，callback，这是我们最为熟悉的回调方式。</p><p>当我们调用某个函数A并以参数的形式传入回调函数后，在A返回之前回调函数会被执行，也就是说我们的主程序会等待回调函数执行完成，这就是所谓的同步回调。</p><figure><img src="https://raw.githubusercontent.com/ET-yzk/picgo/blog/202110251914580.jpg" alt="8" tabindex="0"><figcaption>8</figcaption></figure><p>有同步回调就有异步回调。</p><h2 id="回调对应的编程思维模式" tabindex="-1"><a class="header-anchor" href="#回调对应的编程思维模式" aria-hidden="true">#</a> 回调对应的编程思维模式</h2><p>让我们用简单的几句话来总结一下回调下与常规编程思维模式的不同。</p><p>假设我们想处理某项任务，这项任务需要依赖某项服务S，我们可以将任务的处理分为两部分，调用服务S前的部分PA，和调用服务S后的部分PB。</p><p>在常规模式下，PA和PB都是服务调用方来执行的，也就是我们自己来执行PA部分，等待服务S返回后再执行PB部分。</p><p>但在回调这种方式下就不一样了。</p><p>在这种情况下，我们自己来执行PA部分，然后告诉服务S：“等你完成服务后执行PB部分”。</p><p>因此我们可以看到，现在一项任务是由不同的模块来协作完成的。</p><p>即：</p><ul><li>常规模式：调用完S服务后后我去执行X任务，</li><li>回调模式：调用完S服务后你接着再去执行X任务，</li></ul><p>其中X是服务调用方制定的，区别在于谁来执行。</p><h2 id="为什么异步回调这种思维模式正变得的越来越重要" tabindex="-1"><a class="header-anchor" href="#为什么异步回调这种思维模式正变得的越来越重要" aria-hidden="true">#</a> 为什么异步回调这种思维模式正变得的越来越重要</h2><p>在同步模式下，服务调用方会因服务执行而被阻塞暂停执行，这会导致整个线程被阻塞，因此这种编程方式天然不适用于高并发动辄几万几十万的并发连接场景，</p><p>针对高并发这一场景，异步其实是更加高效的，原因很简单，你不需要在原地等待，因此从而更好的利用机器资源，而回调函数又是异步下不可或缺的一种机制。</p><h2 id="回调地狱-callback-hell" tabindex="-1"><a class="header-anchor" href="#回调地狱-callback-hell" aria-hidden="true">#</a> 回调地狱，callback hell</h2><p>有的同学可能认为有了异步回调这种机制应付起一切高并发场景就可以高枕无忧了。</p><p>实际上在计算机科学中还没有任何一种可以横扫一切包治百病的技术，现在没有，在可预见的将来也不会有，一切都是妥协的结果。</p><p>那么异步回调这种机制有什么问题呢？</p><p>实际上我们已经看到了，异步回调这种机制和程序员最熟悉的同步模式不一样，在可理解性上比不过同步，而如果业务逻辑相对复杂，比如我们处理某项任务时不止需要调用一项服务，而是几项甚至十几项，如果这些服务调用都采用异步回调的方式来处理的话，那么很有可能我们就陷入回调地狱中。</p><p>举个例子，假设处理某项任务我们需要调用四个服务，每一个服务都需要依赖上一个服务的结果，如果用同步方式来实现的话可能是这样的：</p><div class="language-c" data-ext="c"><pre class="language-c"><code>a <span class="token operator">=</span> <span class="token function">GetServiceA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token function">GetServiceB</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
c <span class="token operator">=</span> <span class="token function">GetServiceC</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
d <span class="token operator">=</span> <span class="token function">GetServiceD</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码很清晰，很容易理解有没有。</p><p>我们知道异步回调的方式会更加高效，那么使用异步回调的方式来写将会是什么样的呢？</p><div class="language-c" data-ext="c"><pre class="language-c"><code><span class="token function">GetServiceA</span><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">GetServiceB</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">function</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">GetServiceC</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token function">function</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">GetServiceD</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token function">function</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我想不需要再强调什么了吧，你觉得这两种写法哪个更容易理解，代码更容易维护呢？</p><p>博主有幸曾经维护过这种类型的代码，不得不说每次增加新功能的时候恨不得自己化为两个分身，一个不得不去重读一边代码；另一个在一旁骂自己为什么当初选择维护这个项目。</p><p>异步回调代码稍不留意就会跌到回调陷阱中，那么有没有一种更好的办法既能结合异步回调的高效又能结合同步编码的简单易读呢？</p><p>幸运的是，答案是肯定的。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>在这里，我们从一个实际的例子出发详细讲解了回调函数这种机制的来龙去脉，这是应对高并发、高性能场景的一种极其重要的编码机制，异步加回调可以充分利用机器资源，实际上异步回调最本质上就是<strong>事件驱动编程</strong>。</p>`,111);function d(g,h){const s=t("ExternalLinkIcon");return o(),e("div",null,[l,n("blockquote",null,[n("p",null,[a("整理自 "),n("a",k,[a("码农的荒岛求生"),c(s)])])]),r])}const b=p(u,[["render",d],["__file","Functioncallback.html.vue"]]);export{b as default};
