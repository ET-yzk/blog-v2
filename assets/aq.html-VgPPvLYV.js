import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as p,c as s,f as o}from"./app-HHaGRXeI.js";const r={},t=o("<p><strong>1. 你对于“需要了解代码底层才能写好程序”持何观点？</strong></p><p>不一定，GIL</p><p><strong>2. 系统提高并发性的问题</strong></p><p>从面试的角度来看，做出了如下总结：</p><ol><li>物理层：很多博客里面提到服务器本身的性能，比如提高机器的CPU，增加硬盘，增加内存，升级网卡。还有提到的就是服务器的网络带宽；</li><li>系统操作层 （1）多线程多核编程，消除CPU瓶颈 （2）采用epoll，利用状态检测和通知方式，消除网络I/O阻塞瓶颈 （3）采用事件驱动或者时异步消息机制，可以消除不必要的等待操作 （4）部分采用共享内存的方式进行IPC通信，可以大大提高性能 （5）系统分层</li><li>业务处理 （1）优化数据库性能 （2）采用缓存redis或者memcached</li><li>k8s集群，Nginx，Tengine</li></ol><p><strong>3. 使用过 Redis 实现过异步队列嘛，如何实现</strong></p><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><p><em>如果对方追问可不可以不用 sleep 呢？</em></p><p>list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p><p><em>如果对方追问 pub/sub 有什么缺点？</em></p><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ 等。（这个我觉得就和嵌入式或者是物联网中的 broke 订阅模式（N : N）相似，就比如我有一个远程 broke 服务器，有多个传感器检测信息回传给 broke，broke 收到这个 message，就会进行一次对应频道的广播，只要订阅该频道的接收者都可以收到。但对于我们这里通过 redis 实现的订阅发布模式来说，这里会有一个问题，假如订阅者意外下线了，这个 message 可能就会直接丢失了，对于该问题，我们或许可以设计一个应答机制，要求对发布者作出应答，但这个就要根据实际场景来选择了，避免得不偿失）</p><p><em>如果对方追问 redis 如何实现延时队列？</em></p><p>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为 score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>",13),l=[t];function i(n,c){return p(),s("div",null,l)}const _=e(r,[["render",i],["__file","aq.html.vue"]]);export{_ as default};
