---
icon: b fa-simplybuilt
sidebar: auto
# password: "czxtlx"  v2须直接在 config.js 配置
---

# 操作系统练习

## Exercise 1

1. 在多道程序和分时环境中，多个用户同时共享一个系统，这种情况会导致许多安全问题，因此操作系统中必须加以解决。这些安全问题包括：
   - ==窃取或者复制某用户的程序或数据。==
   - 无法使用独占资源。
   - 难以提供给计算机用户一个方便的程序执行环境。
   - ==未能正确地对使用资源（CPU，内存，磁盘空间等外围设备）情况进行记帐。==
2. 在多道程序和分时环境中，多个用户同时共享一个系统，这种情况导致多种安全问题。在一个分时机器中，能否确保像专用的单机上一样的安全性？
   - 可能不行，因为人们设计的任何保护机制都会不可避免的被别人所破译，而且程序设计人员无法确保所设计的程序是没有漏洞的。
3. 计算机系统中为什么要引入中断（interupt），它的目的是什么？请选出正确的描述。
   - 中断处理装置能识别出中断的类型，转而运行相应的中断处理例程。完成中断处理后再返回到原来被中断处继续执行指令。
   - I/O操作完成后可以通过中断向CPU发出信号，从而避免只能通过程序查询的方式进行I/O操作。
   - 中断是计算机系统内部一种由硬件产生的信号，用来改变CPU执行指令的控制流。
4. 中断和陷阱之间的区别有哪些？
   - 陷阱(trap)是软件产生的中断。
   - I/O操作完成后可以通过中断向CPU发出信号，从而避免只能通过程序查询的方式进行I/O操作。
5. 陷阱指令可以由用户程序有意地发出？
   - 正确
6. 用户程序有意地发出一个陷阱指令，其目的是什么?
   - 调用操作系统功能。
   - 捕获硬件错误。
   - 表示一个I/O操作的完成。
7. 请列出批处理系统的基本特点：
   - 具有相似需求的作业被成批地集合起来，并把它们作为一个整体由操作员或自动作业控制程序控制运行。
   - 通过缓冲区，脱机操作、SPOOLing和多道程序设计等技术，使CPU和I/O设备尽量繁忙地工作，从而提高系统的整体性能。
   - 批处理对于那些交互性较少、而更需要长时间运行的任务来讲最为适合。
8. 请列出交互式系统的基本特点：
   - 这种系统中响应时间要尽量地小（秒级），因为用户提交一个请求后，等着马上要得到结果。
   - 这种系统由许多个短小的事务组成，每个事务的处理结果及下一个要处理哪个事务均是不可预测的。
9. 请列出分时系统的基本特点：
   - CPU能从一个用户快速地切换给另一个用户。
   - 这类系统直接从终端读取控制信息，而把结果直接显示在终端屏幕上。
   - 这类系统采用CPU调度和多道程序设计技术来提供交互式的操作，使系统有很好的经济性。
10. 请列出实时系统的基本特点：
    - 这类系统要求有很好的交互性。
    - 这类系统要求有很好的过载保护能力。
    - 这类系统往往在专用应用系统中使用，它通常从传感器获取输入信息，然后在规定的时间范围内进行处理并作出响应，以确保系统的设计性能。
11. 请列出网络操作系统的基本特点：
    - 运行网络操作系统的计算机是自治的。
    - 通过网络来提供操作系统的功能，如提供文件共享。
12. 请列出并行系统的基本特点：
    - 系统的处理机之间通过系统总线进行通信。
    - 有许多处理机构成，每一个处理机都运行同一个操作系统的拷贝。
13. 请列出分布式系统的基本特点：
    - 系统中的处理机不共享内存和时钟。
    - 系统中的每个处理机都有自己的本地内存。
    - 处理机间通过不同用途的通信网络进行通信，如高速总线、LAN等。
    - 这种系统能将处理任务分布到几个物理的处器机中去运行。
14. 请列出集群系统的基本特点：
    - 集群系统是将多个计算机耦合成一个单一系统来处理计算任务的系统，它可将计算任务分布到集群结点中进行处理。
15. 请列出手持式系统的基本特点：
    - 一种可以完成像记事本，email和网页浏览等简单任务的小型计算机系统。
    - 不同于传统的台式计算机，手持系统只有较小的内存和屏幕，处理器运算速率也慢些。

## Exercise 2

1. 差错检测是操作系统提供给用户的一项基本服务，它可以使用户使用计算机更加方便。请在下列陈述中选择有关差错检测的正确描述。
   - 有了操作系统中的差错检测功能，进程中就不再需要包含用来捕获及纠正系统中可能出现的差错的处理代码。
   - 在软件层面上，必须检查介质以保证数据一致性，如，按设备中存贮块总量的比例对存贮块进行若干次的分配和回收，以检查数据是否一致。差错经常是独立产生的（如，磁盘中数据的损坏），因此必须有一个全局的程序（操作系统）来处理所有差错。
   - 差错检测在硬件、软件层面上都需要进行。
   - 在硬件层面上，所有数据在传送时都需要进行检查以确保在传输过程中不产生差错。在存贮介质中的数据也必须进行检查，以保证写入到介质中的数据没有被修改过。
2. 操作系统中关于文件管理的五个主要操作是什么？
   - 提供对操纵文件和目录的原语支持
   - 创建和删除文件
   - 将文件映射到二级存储器上
   - 创建和删除目录
   - 在稳定（非易失的）存储媒介上备份文件
3. 针对命令解释器的如下陈述，哪些是正确的？
   - 通过系统调用，用户程序可以访问操作系统中的所有功能，因此用户可以开发一个新的命令解释器。
   - 命令解释器从用户或命令文件中读取命令并执行，一般把他们转化一个或多个系统调用加以执行。
   - 命令解释器通常会按需要增删某些功能，因此它一般不属于系统的核心。
   - 每个用户都可以使用由操作系统提供的系统调用接口来开发一个新的命令解释器，如命令解释器允许用户创建、管理进程，并且确定它们通信的方式（如通过管道或文件）。
4. 针对操作系统设计者来讲，使用虚拟机体系结构哪些好处？
   - 系统很易调试，安全问题也容易解决。
   - 虚拟机为操作系统的研究提供了一个很好的平台，它使得许多不同的操作系统可以在一台物理机上执行。

## Exercise 3

1. 关于短期、中期和长期调度，下列哪些陈述是正确的？

   - 长期调度（作业调度）：确定哪些作业调入内存执行。
   - 短期调度程序必须频繁地为CPU选择新进程；长期调度程序则执行频率要低得多，因为它通常选择了一个作业后，要等有作业完成或有新作业到达时才再次启动进行调度。
   - 中期调度通常用于分时系统。它作为一种中等程度的调度，在计算机资源竞争激烈时将部分运行程序从内存移出，降低多道程序设计的程度。等竞争趋缓时再把它们调入，从原被中断处继续执行。
   - 短期调度(CPU调度)：在内存作业中选择就绪状态的进程，分配CPU给它，使之执行。
   - 短期、中期和长期调度的主要不同之处是执行频率。

2. 内核在两个进程上下文切换时会做哪些动作？

   - 总的来说，操作系统必须先保存当前运行进程的状态，然后再恢复下一个将运行的进程的状态。
   - 保存进程的状态主要包括CPU所有寄存器的值以及内存分配情况。
   - 上下文切换时必须执行一些与结构相关的操作，如刷新数据和指令的缓存。

3. 有一段程序如下：

   ```c++
   #include <sys/types.h>  //  pid_t
   #include <sys/wait.h>
   #include <stdio.h>
   #include <unistd.h>
   #include <cstdlib>
   
   int value = 5;
   int main() {
   	pid_t pid;
   	pid = fork();
   	if (pid == 0) {   // 子进程
   		value += 15;  // 数据、堆、栈都将被复制，因此在子进程中的value和主进程互不影响
           printf("CHILD: value = %d\n", value);
           execlp("/bin/ls", "ls", NULL);  // 替换子进程环境，下面的命令将不被执行
           printf("child test\n");
   	}
   	else if (pid > 0) {  // 父进程
   		// for (int i = 0; i < 100000; i++){}
           printf("parent test\n");
   		wait(NULL);      // 等待回收子进程
   		printf("PARENT: value = %d\n", value);
   		exit(0);         // 终止当前进程
   	}
   }
   ```

   
   
   行A将输出什么？
   
   - parent test
   
     CHILD: value = 20
   
     PARENT: value = 5
   
   - 或者【父进程wait(NULL)前的命令与子进程运行快慢顺序不定】
   
   - CHILD: value = 20
   
     parent test
   
     PARENT: value = 5

## TEST 1

> 12、14 待解决

1. 操作系统的主要目的是管理计算机系统资源和管理用户。
   - 错误
   - 【管理电脑硬件与软件资源的程序】
2. 下面的选项中，____________通常不认为是操作系统必须要解决的问题。
   - 管理目录和文件
   - 提供应用程序接口
   - 提供保护和安全机制
   - ==提供C语言编译器==
3. 下面的选项中，____________通常不认为是操作系统必须要解决的问题。
   - 管理目录和文件
   - 提供应用程序接口
   - 提供保护和安全机制
   - ==提供C语言编译器==
4. 通常支持多道程序设计的处理机至少有两种状态，核心态和用户态，这样做给操作系统设计带来的好处有：
   - 使系统能区分出当前状态下哪些指令是不能运行的，从而限制用户进程的访问空间，保护操作系统。
   - 方便操作系统区分哪些进程是系统进程，哪些进程是用户进程。
   - 使用户程序不能访问操作系统程序。
   - 便于设计安全可靠的操作系统。
5. 下列程序中哪个不适合在用户态下执行：
   - 连接程序
   - 编译程序
   - 命令解释程序
   - ==缺页处理程序==
6. 多道程序设计并不是指________。
   - 把多个程序同时加载到内存，并使他们同时处于运行状态
   - 同时把多个程序放入内存并允许它们交替执行和共享系统中的各类资源
   - ==一个处理机中，在同一时刻运行多个程序==
   - 一个处理机中，并发运行多个程序
7. 分时操作系统中，若时间片固定，那么__________，则响应时间越长。
   - ==用户数越多==
   - 内存越多
   - 用户数越少
   - 内存越少
8. 实时控制系统通常只适用生产过程的自动化控制，不能用于监测制导等控制。
   - 错误
9. 下列系统中，通常哪类系统的交互性最差？
   - 交互式系统
   - 实时系统
   - ==批处理系统==
   - 分时系统
10. 操作系统提供给应用程序的接口一般称作：
    - 原语
    - ==系统调用==
    - 库函数
    - 中断
11. 用户在本地终端上通过终端的键盘登陆系统时，首先获得键盘输入信息的程序是：
    - ==中断处理程序==
    - 命令解释程序
    - 系统调用程序
    - 用户登录程序
12. 有以下组合元素：A.进程与进程、B.处理机与外部设备、C.处理机与通信设备、D.外部设备与外部设备。请指出在单处理机系统中，可并行处理的组合是：
    - A、B、C
    - A、B、D【错的】
    - A、C、D
    - B、C、D
13. 软中断是不可屏蔽中断，对吗？
    - 错误
14. 计算机系统中保护操作系统是很重要的一项工作。但为了向用户提供更大的灵活性，通常会尽可能少地对用户加以限制。试问下面的这些指令中至少有哪些指令需加以保护？【5.1/6分】
    - 切换到用户模式
    - 从存放操作系统的存储区上读取数据
    - ==关闭时钟中断==
    - ==打开时钟中断==
    - 从存储操作系统代码区中取指令
    - ==切换到内核模式==
    - ==将数据写到操作系统的数据区==
15. 若用户程序将读取某硬盘文件的第24号逻辑块，则该请求将使用操作系统提供的__________接口。
    - ==系统调用==
    - 图形用户接口
    - 进程
    - 库函数
16. 分布式系统的工作模式可以是：
    - 集群系统
    - C/S系统
    - P2P系统
    - ==以上全是==

## Exercise 4

1. 在多线程的进程中，下面的哪些部分是被该进程中的线程共享的？

   - 堆内存
   - 全局变量

2. 下面的程序使用了Pthread API：

   ```c
   #include <pthread.h>
   #include <stdio.h>
   #include <unistd.h>
   #include <sys/wait.h>
   
   int value = 0;
   void* runner(void* param);  // the thread
   
   int main(int argc, char* argv[]) {
   	int pid;
   	pthread_t tid;
   	pthread_attr_t attr;
   
   	pid = fork();
   	if (pid == 0) {    // child process
   		pthread_attr_init(&attr);
   		pthread_create(&tid, &attr, runner, NULL);
   		pthread_join(tid, NULL);
   		printf("CHILD: value = %d", value);  // 行 C
   	}
   	else if (pid > 0){  // parent process
   		wait(NULL);
   		printf("PARENT: value = %d", value); // 行 P
   	}
   }
   
   void* runner(void* param) {
   	value = 5;
   	pthread_exit(0);
   }
   // 执行 gcc Exercise4.cpp -o Exercise4 -lpthread
   ```

   该程序的行C和行P将分别输出什么？

   - 5,0

1. Linux提供了传统的进程复制的系统调用fork()，还提供了创建线程的系统调用clone()，但Linux并未严格区分进程和线程，而是以任务来统一代替进程和线程。调用clone()时，传送给他一组标志，以决定父任务与子任务之间有多少共享，从而实现类似线程的概念。而有些操作系统，例如windows XP和Solaris，对进程和线程都是有区分的。典型地，这些系统采用标记法，为进程定义一个数据结构来记录指向属于该进程的多个不同的线程的指针。对比这两类系统核心中对进程与线程的支持方法，在如Linux这类将进程与线程同等看待的系统中，下列哪些叙述是正确的？
   - 操作系统的某些代码可以简化。例如，一个调度器可以同等地对待进程和线程，在调度时不需要特别的代码来区分进程与线程。
   - 在资源管理时，为区分哪些线程属于哪个进程，并实现相关的记帐任务，会增加系统的复杂性。
   - 这种进程与线程的一致性会使进程资源的管理变得困难。

## TEST 2

1. 如下程序创建了几个进程？

   ```c
   #include <stdio.h>
   #include <unistd.h>
   
   int main() {
     if (fork()==0){
     	fork();
     	printf("a\n");
     }
     fork();
     printf("b\n");
     return 0;
   }
   ```

   - 6个

2. 注释处应该填什么？

   ```c
   #include <pthread.h>
   #include <stdio.h>
   #include <unistd.h>
   #include <sys/wait.h>
   
   // 执行 gcc Exercise4.cpp -o Exercise4 -lpthread
   
   int val = 0;
   void *runner(void *param);
   void *runner1(void *param);
   int main(int argc, char *argv[]) {
   int pid;
   pthread_t tid, tid1;
   pthread_attr_t attr, attr1;
   pid=fork();
   if (pid==0) {
       pthread_attr_init(&attr);
       pthread_create(&tid, &attr, runner, NULL);
       printf("This is the child. The value is %d ", val);    //输出结果为：This is the child. The value is 0
   
       pthread_attr_init(&attr1);
       pthread_create(&tid1, &attr1, runner1, NULL);
       printf("This is the other thread in child. the value is %d ", val);     //输出结果为：This is the other thread in child. the value is 5
   
       pthread_join(tid, NULL);
       pthread_join(tid1, NULL);
       }
   else {
       wait(NULL);
       printf("This is the parent. The value is %d ",val);    //输出结果为：This is the parent. The value is 0
       }
   }
   void *runner(void *param) {
   val += 5;
   printf("value in runner before sleep: %d ", val);    //输出结果为：value in runner before sleep: 5
   
   sleep(1);
   printf("value in runner after sleep: %d ", val);    //输出结果为：value in runner after sleep: 9
   
   pthread_exit(0);
   }
   void *runner1(void *param) {
   val += 4;
   pthread_exit(0);
   }
   ```

   - 答案如上注释

3. 在操作系统的概念中，程序与进程的重要区别之一是_____________。

   - 程序有运行时的状态而进程没有
   - 程序可占有资源而进程不能
   - 进程是静态的而程序是动态的
   - ==进程是动态的而程序是静态的==

   Question 1: NA out of 10 in 0 attempt(s)

   采用时间片轮转调度策略时，当处于运行状态的进程用完一个时间片后，它的状态是__________ 。

   -  消亡
   -  运行
   -  ==阻塞==
   -  就绪

   Question 2: NA out of 10 in 0 attempt(s)

   进程间通信方式很多，包括下面的：

   - ==共享内存机制==
   - ==信号量及其原语操作控制的共享存储区通信机制==
   - ==信箱和发信收信原语的消息传递通信机制==
   - 高级程序设计语言所提供的通信程序
   - ==信号通信机制==
   - ==管道提供的共享通信机制==

   Question 3: NA out of 10 in 0 attempt(s)

   一个单处理机系统中，最多只能有一个进程处于运行状态。

   - 正确

   Question 4: NA out of 10 in 0 attempt(s)

   任何进程都可以调用创建进程原语来创建进程。

   - 正确
   - ==错误==

   Question 5: NA out of 10 in 0 attempt(s)

   有以下操作：A.用户登录成功； B.设备分配； C.启动程序执行。下面的哪个操作的组合标志着创建了新的进程：

   - 仅A和B
   - ==仅A和C==
   - 仅B和C
   - A、B、C

   Question 7: NA out of 10 in 0 attempt(s)

   下面这段C语言的程序，请填入运行到指定语句时输出的结果。
   int val=5;
   main() {
   pid_t pid;
   val += 5;
   if ((pid=fork())<0) {val += 5; exit(1);}
   if (pid==0) {
     val += 5;
     printf("%d ", val);  //输出结果为：。
     }
   else {
     printf("%d ", val);  //输出结果为：。
     exit(0);
     }
   }

   Question 8: NA out of 10 in 0 attempt(s)

   同一进程中的线程不能共享的是：

   - 进程的代码段
   - 进程所打开的文件
   - 进程的全局变量
   - 进程的id
   - ==线程的程序计数器==
   - ==进程中线程的栈指针==

## Exercise 5

1. ==？==CPU利用率和响应时间这两个调度准则在某些场景下会有冲突。请判断下列陈述中哪些是正确的？
   - 降低上下文切换的频率会降低CPU利用率。
   - ==如果上下文切换的开销减少，则CPU利用率会增加。==
   - ==提高CPU的利用率可能会增加进程的响应时间。==
   - ==降低上下文切换的频率可减少上下文切换的开销。==
   - ==降低上下文切换的频率会增加进程的响应时间。==

2. 平均周转时间和最大等待时间这两个调度准则在某些场景下会有冲突。请判断下列陈述中哪些是正确的？
   - 最短作业优先的调度策略可能会将运行时间较长的作业饿死，但它们的等待时间可能会缩短。
   - ==最短作业优先的调度策略将获得最小的平均周转时间。==
   - ==最短作业优先的调度策略可能会将运行时间较长的作业饿死，从而增加它们的等待时间。==
   - 最长作业优先的调度策略将获得最小的平均周转时间。

3. I/O设备的利用率和CPU利用率这两个调度准则在某些场景下会有冲突。请判断下列陈述中哪些是正确的？

   - ==只要I/O型的进程一就绪，就调度运行该进程，虽然会增加上下文切换的开销，但可获得最大的I/O设备的利用率。==
   - ==只要I/O型的进程一就绪，就调度运行该进程，既增加了上下文切换的开销，也减小了I/O设备的利用率。
   - 执行运行时间较长的CPU型任务，并且期间不作上下文切换，则将获得最小的CPU利用率。

4. 考虑下列进程集，占用的CPU时间长度以毫秒来计算：
   ![img](http://www.imathas.com/cgi-bin/mimetex.cgi?%7B%5Cleft%5B%5Cmatrix%7B%7BP%7D%7Br%7D%7Bo%7D%7Bc%7D%7Be%7D%7Bs%7D%7Bs%7D%26%7BB%7D%7Bu%7D%7Br%7D%7Bs%7D%7Bt%7D%7BT%7D%7Bi%7D%7Bm%7D%7Be%7D%26%7BP%7D%7Br%7D%7Bi%7D%7B%5Cquad%5Ctext%7Bor%7D%5Cquad%7D%7Bi%7D%7BN%7D%7Bu%7D%7Bm%7D%7Bb%7D%7Be%7D%7Br%7D%5C%5C%7BP%7D%7B1%7D%26%7B10%7D%26%7B3%7D%5C%5C%7BP%7D%7B2%7D%26%7B1%7D%26%7B1%7D%5C%5C%7BP%7D%7B3%7D%26%7B2%7D%26%7B3%7D%5C%5C%7BP%7D%7B4%7D%26%7B1%7D%26%7B4%7D%5C%5C%7BP%7D%7B5%7D%26%7B5%7D%26%7B2%7D%7D%5Cright%5D%7D)
   假设进程在时刻0以P1，P2，P3，P4，P5的顺序到达。
   则对下列调度策略，每个进程的周转时间分别为多少：FCFS, RR (时间片长=1), SJF, 以及非抢占式的优先级调度（小优先数表示高优先级)？
   
   - ![[(P1),(P2),(P3),(P4),(P5)]](https://gitee.com/yzketx/image-markdown/raw/master/img/202204021542980.gif) = <img src="https://gitee.com/yzketx/image-markdown/raw/master/img/202204021545581.png" alt="image-20220402154511484" style="zoom:60%;" />
   
5. 同上，则对下列调度策略，每个进程的等待时间分别为多少：FCFS, RR (时间片长=1), SJF, 以及非抢占式的优先级调度（小优先数表示高优先级）？
   - ![[(P1),(P2),(P3),(P4),(P5)]](https://gitee.com/yzketx/image-markdown/raw/master/img/202204021547324.gif) = <img src="https://gitee.com/yzketx/image-markdown/raw/master/img/202204021551219.png" alt="image-20220402155130132" style="zoom:60%;" />

6. 下列哪些调度策略可能会引起饿死?

   - ==优先级调度。==
   - 时间片轮转RR。
   - 先来先服务FCFS。
   - ==短作业优先SJF。==

7. 某系统采用多级队列调度策略进行调度，请问用户采取下列哪些措施可从分配给他的CPU时间片中获得最大运行时间？

   - 放弃使用第一次分配给他的时间片。
   - 每次都用完分配给他的时间片。
   - ==使用分配给它的时间片中的绝大部分，但在时间片结束前放弃CPU，从而提高与进程有关的优先级。==
   - 使用分配给它的时间片中的一小部分就放弃CPU。

8. 在对待短作业的问题上，对下列调度算法：FCFS，RR，多级反馈队列
   请选择正确的叙述。

   调度算法

   - ==c== FCFS
   - ==b== 多级反馈队列
   - ==a== RR

   叙述：

   a. 平等对待所有作业（给各作业分配相等的时间片），因此短作业可比较快地处理完成而离开系统。
   
   b. 该调度算法虽然没有给短作业明显的照顾，但长作业的优先组长会逐步被降低，从而相对而言提高了短作业获得CPU的机会。
   
   c. 该调度算法未照顾短作业，若短作业在长作业后到达，该短作业会有较长的等待时间。

## TEST 6



### Exercise 6



### Exercise 7

1. 一种可以预防死锁的办法是为临界资源族设置一个高级别的资源，当进程要申请临界资源族中的资源时，必须先申请该资源。如，当多个线程试图访问同步对象A...E时就有可能会发生死锁（这些同步对象可能包含互斥、信号灯、条件变量等），我们可以引入第6个对象F来预防死锁。当一个线程想对对象A...E中的任何一个上锁时，他必须先对F上锁。这种方案被称作逷制：对象A...E的锁包含于对象F的锁中。
   比较这种方案和7.4.4节的循环等待方案，请为下面的空缺选择最合适的答案：这可能是一个 ==不好的== 的解决方案，因为它 ==扩大管辖范围==。好的解决方案应该是定义一个上锁策略，并尽量地 ==缩小管辖范围== 。

2. 比较循环等待方案和死锁避免方案（如银行家算法），针对下述相关问题：
   a. 运行开销
   b. 系统呑吐量
   请为空白处选择合适的答案：因为要跟踪当前资源的分配情况，一个死锁避免方案可能会 ==增加== 运行开销。然而，相对于静态预防死锁的方案，死锁避免方案允许对资源更多的并发访问，因此，死锁避免方案又能 ==增加== 系统呑吐量。

3. 在一个实际的系统中，无论是可用资源还是进程对资源的需求，都不可能在长时间（如几个月）内保持一致。如资源的损坏或更换，新进程的到来及老进程的撤销，新资源的加入等等。如果采用银行家算法来控制死锁，下面的哪些变化在什么状况下是安全的（不会导致死锁）？

   - 增加可用性（增加新资源）

     ==这种变化是安全的，不会引起任何问题==

   - 减少可用性（从系统中撤掉一些资源）

     ==这种变化会对系统产生影响，它会使系统产生死锁，因为系统需要有一定数量的可用资源==

   - 增加进程的 Max数（增加进程的资源需求数）
     
     ==这种变化会对系统产生影响，并且引发产生死锁的可能==

   - 减少进程的 Max数（减少进程的资源需求数）

     ==这种变化是安全的，不会引起任何问题==

   - 增加进程数

     ==若资源分配给新进程，而不会使系统进入不安全状态，则这种变化是安全的==

   - 减少进程数

     ==这种变化是安全的，不会引起任何问题==

4. 考虑下面的系统快照：

      |      | Allocation |   Max   | Available |
      | :--: | :--------: | :-----: | :-------: |
      |      |  A B C D   | A B C D |  A B C D  |
      |  P0  |  0 0 1 2   | 0 0 1 2 |  1 5 2 0  |
      |  P1  |  1 0 0 0   | 1 7 5 0 |           |
      |  P2  |  1 3 5 4   | 2 3 5 6 |           |
      |  P3  |  0 6 3 2   | 0 6 5 2 |           |
      |  P4  |  0 0 1 4   | 0 6 5 6 |           |

      - 使用银行家算法填充Need矩阵。

        |      | A    | B    | C    | D    |
        | ---- | ---- | ---- | ---- | ---- |
        | P0   | 0    | 0    | 0    | 0    |
        | P1   | 0    | 7    | 5    | 0    |
        | P2   | 1    | 0    | 0    | 2    |
        | P3   | 0    | 0    | 2    | 0    |
        | P4   | 0    | 6    | 4    | 2    |

      - 此时的系统安全吗？

        ==安全==

      - 进程P1提交了一个资源申请(0,4,2,0)，能立即分配给他吗？

        ==能==

## TEST 4

1. 临界区是指进程中用于实现进程通信的那段代码。

   - ==错误==
   - 正确 `指进程中用于实现共享资源的那段代码`

2. ==？==用信号量的wait、signal操作可以解决__________互斥问题。

   - 某些
   - 所有
   - 一类 ==x==
   - 以上说法都不正确

3. 对两个并发进程，其互斥信号量为mutex；若mutex=0，则表示：

   > 当mutex＝1时，表示两个进程皆未进入需要互斥的临界区； 当mutex＝0时，表示有一个进程进入临界区且没有进程等待进入时； 当mutex＝－1时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。

   - 临界区内有一个进程，且另一个进程正处于等待进入临界区状态
   - 临界区内没有进程
   - ==临界区内有一个进程，且另一个进程也未申请进入临界区==
   - 临界区内有二个进程

4. 在15个生产者、11个消费者共享容量为10的缓冲器的生产者-消费者问题中，互斥使用缓冲器的信号量mutex的初始值为__________。

   > 当前只运行一个进程运行

   - ==1==
   - 10
   - 11
   - 15

5. 设与某资源相关的信号量初值为5，当前值为2。若M表示（当前）该资源的可用个数，N表示（当前）等待该资源的进程数。则M、N分别是：

   > 信号量当前值为 2，说明当前资源可用数 2；
   >
   > 又当前仍有可用资源，所以当前无等待进程。

   - 0，0
   - 0，1
   - 1，0
   - 1，2

   - ==2，0==
   - 2，2
   - 3，0
   - 5，0

6. 定义进程p0和p1的共享变量及初值为：

   ```c
   int turn=0;
   boolean flag[2]；
   flag[0]=FALSE; flag[1]=FALSE;
   // 若进程p0和p1访问临界资源的类C代码实现如下：(记i为0时j为1，i为1时j为0)
   void Pi() { //进程pi
     while (TRUE) {
       turn = j;
       flag[i] = TRUE;
       while (flag[j]&&turn==j);
       // 临界区;
       flag[i] = FALSE;
       }
   }
   ```


   则并发执行进程p0和p1时产生的情况是：

   - 不能保证进程互斥进入临界区
   - 能保证进程互斥进入临界区，但不能保证“有空让进”
   - ==能保证进程互斥进入临界区，能保证“有空让进”==

7. 有两个并发执行的进程P1和P2，共享初值为2的变量x。P1对x加1，P2对x减2。减2操作通过二个减1操作来完成，加1和减1操作的指令序列分別如下所示：
   **//加1操作**
   get R1, x //取x的值到寄存器R1中
   inc R1 //寄存器R1 加 1
   save R1, x //将 R1 的内容存入 x
   **//减 1 操作**
   get R2, x
   dec R2 //寄存器 R2 减 1
   save R2, x
   两个操作完成后，x的值为：

   - ==可能为0、1、2、3==
   - 可能为0、1、3
   - 可能为0、2、3
   - 可能为1、2、3

8.  数组buff[0..n-1] 中的每个元素都是一个缓冲区。现用信号量机制来实现向缓冲区放一个数据data的算法put(data)和从缓冲区取一个数据data的算法get(data)。设一个缓冲区正好放一个数据，先放入的数据要先取出，且put和get可并发运行。
   请完成下列算法流程的填充：

   ```c
   int front=rear=0;  // 相当于in/out，指针
   semaphore mutex_put=mutex_get=1; //信号量[内核对象]
   semaphore empty=n; full=0;
   put(data) {
       // 空1;
       wait(mutex_put);
       put data to buff[rear];
       rear=mod(rear+1, n);
       // 空2;
       signal(full);
   }
   get(data) {
       // 空3;
       // 空4;
       get data from buff[front];
       front=mod(front+1, n);
       signal(mutext_get);
       signal(empty);
   }
   ```

   > 1.互斥的wait(mutex)和signal(mutex)必须成对地出现；
   >
   > 2.对资源信号量empty和full的wait和signal操作，同样需要成对地出现，但它们分别处于不同的程序中。
   >
   > 3.每个程序中的多个wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。

   > - 空缓冲区不为满，生产者才能将生产的数据放入缓冲区中。
   >
   > - 满缓冲区不为空，消费者才能从缓冲区中取数据。
   > - 为了保证进程同步，生产者与消费者不可以同时访问缓冲区。

   - ==wait(empty)==
   - ==signal(mutex_put)==
   - ==wait(full)==
   - ==wait(mutex_get)==

9. 某理发馆有2个理发师和6个供顾客等待的座位。顾客到达理发馆时，若有空座位，则到取号机上领取一个唯一号，等待叫号。取号机每次仅允许一位顾客使用，get_ticket()返回顾客取到的号，put_ticket()返回理发师待服务的号。当理发师空闲时，通过叫号选取一位顾客，并为其理发。请为顾客和理发师的活动过程描述算法填充合适的语句：

   ```c
   Semaphore seats= // 空1;
   Semaphore mutex= // 空2;
   Semaphore customer= // 空3;
   Semaphore barber=0;
   int ticket_now;
   cobegin {
   Process 顾客i {
       // 空4;
       wait(mutex);
       // 从取号机上取一个号
       int tn=get_ticket();
       signal(mutex);
       // 空5;
       while (ticket_now < tn){
           wait(barber); //等待叫号；
       }
       // 空6;
       接受服务（理发）;
       };
   Process 理发师j {
       while (true) {
       	// 空7;
       	// 空8;
           // 从取号机上获取待服务的号
           ticket_now=put_ticket();
           signal(mutex);
           signal(barber);
           为顾客服务（理发）;
           }
       }
   } coend
   ```

   > **临界区**: 我们把并发进程中与共享变量有关的程序段称为临界区。
   >
   > **信号量**: 信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。
   >
   > **进程的互斥**: 是指当有若干个进程都要使用某一共享资源时，任何时刻最多只允许-一个进程去使用该资源，其他要使用它的进程必须等待，直到该资源的占用着释放了该资源。
   >
   > **进程的同步**: 是指在并发进程之间存在这一种制约关系，一个进程依赖另一个进程的消息，当一个进程没有得到另一个进程的消息时应等待，直到消息到达才被唤醒。
   >
   > `pv操作又称wait,signal原语`: 主要是操作进程中对进程控制的信息量的加减控制。
   >
   > p[wait]: 信号量 - 1，如果信息量>=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
   >
   > v[signal]: 信号量 + 1，如果信息量>0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。

   > n个理发师通过开n个理发师进程实现？

   - ==6==
   - ==1==
   - ==0==
   - ==wait(seats)==  // 等待座位减少 1
   - ==signal(customer)==  // 顾客加 1
   - ==signal(seats)==  // 等待座位加 1
   - ==wait(customer)==  // 顾客减少 1
   - ==wait(mutex)==  // 等待取号

## Online

[现代操作系统 第三章 内存管理 习题](https://blog.csdn.net/MarshaZheng/article/details/82715636)

[2018操作系统期末试题](https://blog.csdn.net/MarshaZheng/article/details/84639441?spm=1001.2014.3001.5502)

有一个文件描述符为fd的已打开的文件，其内容是字节序列：49, 3, 4, 4, 4, 53, 57, 66, 4, 4, 4, 4, 49, 69, 101, 54, 49, 50, 51, 52。char buffer[10]初始化为全0，则依次全部执行完下面的系统调用：
  1）lseek(fd, 4, SEEK_SET);    2）read(fd, buffer, 4);
  3）lseek(fd, 3, SEEK_CUR);    4）read(fd, buffer+6, 3);
  5）lseek(fd, -6, SEEK_END);    6）read(fd, buffer+4, 1);
后，buffer中的值是：4、53、57、66、69、0、66、4、4、0。
其中系统调用lseek()中SEEK_SET为从文件头开始、SEEK_CUR为从当前位置开始、SEEK_END为从文件尾开始。

SEEK_SET 将读写位置指向文件头后再增加offset个位移量。

SEEK_CUR 以目前的读写位置往后增加offset个位移量。

SEEK_END 将读写位置指向文件尾后再增加offset个位移量。

当whence 值为SEEK_CUR 或SEEK_END时，参数offet允许负值的出现。

**read参数**：int handle 为要读取的文件

​     void *buf 为要将读取的内容保存的缓冲区

​     int len  读取文件的长度
